<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle Game Spektakuler</title>
    <style>
        /* Reset dan Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            min-height: 100vh;
            background: linear-gradient(135deg, #f5d9ff 0%, #e0c4fd 100%);
            padding: 20px;
            color: #4a1d96;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            color: #5b21b6;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .header p {
            font-size: 1.1rem;
            color: #6b46c1;
        }

        /* Game Controls */
        .controls {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .controls-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background-color: #7c3aed;
            color: white;
        }

        .btn-primary:hover {
            background-color: #6d28d9;
        }

        .btn-outline {
            background-color: transparent;
            border: 2px solid #7c3aed;
            color: #7c3aed;
        }

        .btn-outline:hover {
            background-color: #ede9fe;
        }

        .btn-sm {
            padding: 8px 12px;
            font-size: 0.9rem;
        }

        select {
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #ddd;
            font-weight: 600;
            color: #4a1d96;
            flex: 1;
        }

        /* Stats */
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .badge {
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            border: 1px solid #ddd;
        }

        /* Progress */
        .progress-container {
            margin-top: 15px;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .progress-bar {
            height: 8px;
            background-color: #e9d5ff;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background-color: #7c3aed;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        /* Game Area */
        .game-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .preview-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .preview-image {
            max-width: 100%;
            height: 200px;
            object-fit: contain;
            border-radius: 8px;
            margin-bottom: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .preview-text {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .preview-desc {
            color: #666;
            margin-bottom: 15px;
            font-size: 0.9rem;
        }

        /* Puzzle Board */
        .puzzle-board {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .puzzle-header {
            padding: 15px 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .puzzle-content {
            padding: 20px;
        }

        .hint-image {
            width: 100%;
            height: 150px;
            object-fit: contain;
            opacity: 0.5;
            border-radius: 8px;
            border: 2px dashed #c4b5fd;
            margin-bottom: 15px;
            position: relative;
        }

        .hint-badge {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #7c3aed;
            color: white;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
        }

        .puzzle-container {
            position: relative;
            background-color: #f9fafb;
            border-radius: 12px;
            border: 2px dashed #c4b5fd;
            margin: 0 auto;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .puzzle-container.active {
            border-color: #7c3aed;
            background-color: #f5f3ff;
        }

        .puzzle-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.3;
            background-image: 
                linear-gradient(to right, rgba(124, 58, 237, 0.3) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(124, 58, 237, 0.3) 1px, transparent 1px);
        }

        .puzzle-piece {
            position: absolute;
            z-index: 1;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
        }

        .piece-check {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background-color: #10b981;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.7rem;
        }

        .empty-state {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #9ca3af;
        }

        .empty-emoji {
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .empty-text {
            font-size: 0.8rem;
        }

        .selected-indicator {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 2px solid #7c3aed;
            border-radius: 12px;
            pointer-events: none;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }

        .selected-hint {
            padding: 10px;
            background-color: #f5f3ff;
            border-radius: 8px;
            text-align: center;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #5b21b6;
            font-weight: 500;
        }

        /* Pieces Area */
        .pieces-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }

        .piece-thumbnail {
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 8px;
            overflow: hidden;
        }

        .piece-thumbnail:hover {
            transform: scale(1.05);
        }

        .piece-thumbnail.selected {
            transform: scale(1.05);
            box-shadow: 0 0 0 2px #7c3aed;
        }

        .piece-number {
            position: absolute;
            top: -5px;
            left: -5px;
            width: 25px;
            height: 25px;
            background-color: #7c3aed;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .piece-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(124, 58, 237, 0.2);
            border-radius: 8px;
            animation: pulse 1.5s infinite;
        }

        .no-pieces {
            text-align: center;
            padding: 40px 0;
            color: #9ca3af;
        }

        .no-pieces-emoji {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        .instructions {
            background-color: #f5f3ff;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .instructions-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: #5b21b6;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .instructions-list {
            font-size: 0.8rem;
            color: #5b21b6;
        }

        .instructions-list p {
            margin-bottom: 3px;
        }

        /* Celebration Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .modal-content {
            background-color: white;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            overflow: hidden;
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }

        .modal-overlay.active .modal-content {
            transform: translateY(0);
        }

        .modal-header {
            padding: 20px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #5b21b6;
        }

        .modal-body {
            padding: 20px;
            text-align: center;
        }

        .modal-image {
            width: 100%;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .modal-stats {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
        }

        /* Responsive */
        @media (min-width: 768px) {
            .header h1 {
                font-size: 3rem;
            }

            .controls-row {
                flex-wrap: nowrap;
            }

            .pieces-container {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (min-width: 1024px) {
            .game-area {
                flex-direction: row;
            }

            .preview-card {
                flex: 1;
            }

            .puzzle-section {
                flex: 2;
            }

            .pieces-container {
                grid-template-columns: repeat(5, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>
                <span>❤️</span>
                Puzzle Game Spektakuler
                <span>❤️</span>
            </h1>
            <p>Susun puzzle foto dengan bentuk tradisional yang menantang!</p>
        </div>

        <!-- Game Controls -->
        <div class="controls">
            <div class="controls-row">
                <button id="upload-btn" class="btn btn-outline">
                    <span>📤</span> Upload
                </button>
                <select id="difficulty-select">
                    <option value="2">Mudah (2x2)</option>
                    <option value="3" selected>Sedang (3x3)</option>
                    <option value="4">Sulit (4x4)</option>
                </select>
                <button id="start-btn" class="btn btn-primary">
                    <span>▶️</span> Mulai
                </button>
                <button id="reset-btn" class="btn btn-outline btn-sm">
                    <span>🔄</span>
                </button>
            </div>

            <div class="stats">
                <div class="stat-item">
                    <span>Waktu:</span>
                    <span id="time-display" class="badge">00:00</span>
                </div>
                <div class="stat-item">
                    <span>Gerakan:</span>
                    <span id="moves-display" class="badge">0</span>
                </div>
            </div>

            <div class="progress-container">
                <div class="progress-header">
                    <span>Progress:</span>
                    <span id="progress-percent">0%</span>
                </div>
                <div class="progress-bar">
                    <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
                </div>
            </div>

            <div id="game-actions" class="controls-row" style="display: none; margin-top: 15px;">
                <button id="hint-btn" class="btn btn-outline">
                    <span>👁️</span> Hint
                </button>
                <button id="shuffle-btn" class="btn btn-outline">
                    <span>🔀</span> Acak
                </button>
            </div>
        </div>

        <!-- Game Area -->
        <div class="game-area">
            <!-- Preview Area (shown when game not started) -->
            <div id="preview-card" class="preview-card">
                <img id="preview-image" src="https://via.placeholder.com/400x300?text=Puzzle+Image" alt="Preview" class="preview-image">
                <h3 class="preview-text">Siap bermain puzzle?</h3>
                <p class="preview-desc">Klik "Mulai" untuk memecah foto menjadi puzzle dengan bentuk tradisional!</p>
                <button id="start-btn-2" class="btn btn-primary" style="width: 100%;">
                    <span>▶️</span> Mulai Bermain
                </button>
            </div>

            <!-- Puzzle Area (shown when game started) -->
            <div id="puzzle-section" class="puzzle-section" style="display: none; flex: 2;">
                <!-- Puzzle Board -->
                <div class="puzzle-board">
                    <div class="puzzle-header">
                        <span>🧩 Area Puzzle</span>
                        <span id="selected-piece-badge" class="badge" style="display: none;">Piece 1 dipilih</span>
                    </div>
                    <div class="puzzle-content">
                        <div id="hint-container" style="display: none;">
                            <div style="position: relative;">
                                <img id="hint-image" src="https://via.placeholder.com/400x300?text=Hint" alt="Hint" class="hint-image">
                                <span class="hint-badge">Hint</span>
                            </div>
                        </div>

                        <div id="puzzle-container" class="puzzle-container" style="width: 300px; height: 300px;">
                            <div class="puzzle-grid"></div>
                            <div class="empty-state">
                                <div>
                                    <div class="empty-emoji">🧩</div>
                                    <div class="empty-text">Pilih piece, lalu klik disini</div>
                                </div>
                            </div>
                        </div>

                        <div id="selected-hint" class="selected-hint" style="display: none;">
                            👆 Klik area puzzle untuk pasang piece <span id="selected-piece-number">1</span>
                        </div>
                    </div>
                </div>

                <!-- Pieces Area -->
                <div class="puzzle-board" style="margin-top: 20px;">
                    <div class="puzzle-header">
                        <span>🔀 Pieces Puzzle</span>
                        <span id="remaining-pieces" class="badge">0 tersisa</span>
                    </div>
                    <div class="puzzle-content">
                        <div id="pieces-container" class="pieces-container">
                            <!-- Pieces will be added here dynamically -->
                        </div>

                        <div id="no-pieces" class="no-pieces" style="display: none;">
                            <div class="no-pieces-emoji">🎉</div>
                            <div>Semua pieces sudah dipasang!</div>
                        </div>

                        <div class="instructions">
                            <div class="instructions-title">
                                <span>💡</span> Cara bermain:
                            </div>
                            <div class="instructions-list">
                                <p>1. Klik piece untuk memilih (akan highlight)</p>
                                <p>2. Klik area puzzle untuk memasang</p>
                                <p>3. Piece akan terpasang jika posisi benar</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Celebration Modal -->
    <div id="celebration-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">🎉 Selamat! 🎉</h2>
            </div>
            <div class="modal-body">
                <img id="modal-image" src="https://via.placeholder.com/400x300?text=Completed+Puzzle" alt="Completed Puzzle" class="modal-image">
                <h3 style="margin-bottom: 15px; font-size: 1.2rem;">Puzzle Berhasil Diselesaikan!</h3>
                
                <div class="modal-stats">
                    <p>⏱️ Waktu: <span id="modal-time">00:00</span></p>
                    <p>🎯 Gerakan: <span id="modal-moves">0</span></p>
                    <p>🏆 Tingkat: <span id="modal-difficulty">Sedang (3x3)</span></p>
                </div>

                <div class="modal-actions">
                    <button id="play-again-btn" class="btn btn-primary" style="flex: 1;">
                        Main Lagi
                    </button>
                    <button id="close-modal-btn" class="btn btn-outline" style="flex: 1;">
                        Tutup
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden Canvas for Image Processing -->
    <canvas id="canvas" style="display: none;"></canvas>

    <!-- Hidden File Input -->
    <input type="file" id="file-input" accept="image/*" style="display: none;">

    <script>
        // Game State
        const gameState = {
            image: "https://images.unsplash.com/photo-1516589178581-6cd7833ae3b2?ixlib=rb-1.2.1&auto=format&fit=crop&w=500&q=80",
            puzzlePieces: [],
            selectedPiece: null,
            difficulty: 3,
            stats: {
                moves: 0,
                timeElapsed: 0,
                isComplete: false
            },
            isPlaying: false,
            isPaused: false,
            showHint: false,
            tabPattern: []
        };

        // DOM Elements
        const elements = {
            // Controls
            uploadBtn: document.getElementById('upload-btn'),
            difficultySelect: document.getElementById('difficulty-select'),
            startBtn: document.getElementById('start-btn'),
            startBtn2: document.getElementById('start-btn-2'),
            resetBtn: document.getElementById('reset-btn'),
            hintBtn: document.getElementById('hint-btn'),
            shuffleBtn: document.getElementById('shuffle-btn'),
            gameActions: document.getElementById('game-actions'),
            
            // Stats
            timeDisplay: document.getElementById('time-display'),
            movesDisplay: document.getElementById('moves-display'),
            progressPercent: document.getElementById('progress-percent'),
            progressFill: document.getElementById('progress-fill'),
            
            // Game Areas
            previewCard: document.getElementById('preview-card'),
            puzzleSection: document.getElementById('puzzle-section'),
            previewImage: document.getElementById('preview-image'),
            hintContainer: document.getElementById('hint-container'),
            hintImage: document.getElementById('hint-image'),
            puzzleContainer: document.getElementById('puzzle-container'),
            selectedPieceBadge: document.getElementById('selected-piece-badge'),
            selectedHint: document.getElementById('selected-hint'),
            selectedPieceNumber: document.getElementById('selected-piece-number'),
            piecesContainer: document.getElementById('pieces-container'),
            noPieces: document.getElementById('no-pieces'),
            remainingPieces: document.getElementById('remaining-pieces'),
            
            // Modal
            celebrationModal: document.getElementById('celebration-modal'),
            modalImage: document.getElementById('modal-image'),
            modalTime: document.getElementById('modal-time'),
            modalMoves: document.getElementById('modal-moves'),
            modalDifficulty: document.getElementById('modal-difficulty'),
            playAgainBtn: document.getElementById('play-again-btn'),
            closeModalBtn: document.getElementById('close-modal-btn'),
            
            // Canvas
            canvas: document.getElementById('canvas'),
            ctx: document.getElementById('canvas').getContext('2d'),
            
            // File Input
            fileInput: document.getElementById('file-input')
        };

        // Timer
        let timer = null;

        // Initialize
        function init() {
            // Set default image
            elements.previewImage.src = gameState.image;
            elements.hintImage.src = gameState.image;
            elements.modalImage.src = gameState.image;
            
            // Event Listeners
            elements.uploadBtn.addEventListener('click', () => elements.fileInput.click());
            elements.fileInput.addEventListener('change', handleFileUpload);
            elements.difficultySelect.addEventListener('change', (e) => {
                gameState.difficulty = parseInt(e.target.value);
            });
            elements.startBtn.addEventListener('click', startGame);
            elements.startBtn2.addEventListener('click', startGame);
            elements.resetBtn.addEventListener('click', resetGame);
            elements.hintBtn.addEventListener('click', toggleHint);
            elements.shuffleBtn.addEventListener('click', shufflePieces);
            elements.puzzleContainer.addEventListener('click', handlePuzzleAreaClick);
            elements.playAgainBtn.addEventListener('click', playAgain);
            elements.closeModalBtn.addEventListener('click', closeModal);
            
            // Set initial difficulty
            gameState.difficulty = parseInt(elements.difficultySelect.value);
        }

        // File Upload
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    gameState.image = e.target.result;
                    elements.previewImage.src = gameState.image;
                    elements.hintImage.src = gameState.image;
                    elements.modalImage.src = gameState.image;
                    resetGame();
                };
                reader.readAsDataURL(file);
            }
        }

        // Generate tab pattern
        function generateTabPattern(difficulty) {
            const pattern = [];
            for (let row = 0; row < difficulty; row++) {
                pattern[row] = [];
                for (let col = 0; col < difficulty - 1; col++) {
                    pattern[row][col] = Math.random() > 0.5;
                }
            }
            return pattern;
        }

        // Create puzzle shape
        function createPuzzleShape(row, col, pieceWidth, pieceHeight, difficulty, tabPattern) {
            const tabSize = Math.min(pieceWidth, pieceHeight) * 0.15;
            const tabWidth = pieceWidth * 0.3;
            const tabHeight = pieceHeight * 0.3;

            // Determine tabs
            const hasTopTab = row > 0 ? (tabPattern[row - 1]?.[col] ?? false) : false;
            const hasRightTab = col < difficulty - 1 ? (tabPattern[row]?.[col] ?? false) : false;
            const hasBottomTab = row < difficulty - 1 ? !(tabPattern[row]?.[col] ?? false) : false;
            const hasLeftTab = col > 0 ? !(tabPattern[row]?.[col - 1] ?? false) : false;

            // Create SVG path
            let path = `M 0 0`;

            // Top edge
            if (row === 0) {
                path += ` L ${pieceWidth} 0`;
            } else if (hasTopTab) {
                path += ` L ${pieceWidth * 0.35} 0`;
                path += ` L ${pieceWidth * 0.35} ${-tabSize}`;
                path += ` Q ${pieceWidth * 0.4} ${-tabSize * 1.3} ${pieceWidth * 0.5} ${-tabSize * 1.3}`;
                path += ` Q ${pieceWidth * 0.6} ${-tabSize * 1.3} ${pieceWidth * 0.65} ${-tabSize}`;
                path += ` L ${pieceWidth * 0.65} 0`;
                path += ` L ${pieceWidth} 0`;
            } else {
                path += ` L ${pieceWidth * 0.35} 0`;
                path += ` Q ${pieceWidth * 0.4} ${tabSize * 0.8} ${pieceWidth * 0.5} ${tabSize * 0.8}`;
                path += ` Q ${pieceWidth * 0.6} ${tabSize * 0.8} ${pieceWidth * 0.65} 0`;
                path += ` L ${pieceWidth} 0`;
            }

            // Right edge
            if (col === difficulty - 1) {
                path += ` L ${pieceWidth} ${pieceHeight}`;
            } else if (hasRightTab) {
                path += ` L ${pieceWidth} ${pieceHeight * 0.35}`;
                path += ` L ${pieceWidth + tabSize} ${pieceHeight * 0.35}`;
                path += ` Q ${pieceWidth + tabSize * 1.3} ${pieceHeight * 0.4} ${pieceWidth + tabSize * 1.3} ${pieceHeight * 0.5}`;
                path += ` Q ${pieceWidth + tabSize * 1.3} ${pieceHeight * 0.6} ${pieceWidth + tabSize} ${pieceHeight * 0.65}`;
                path += ` L ${pieceWidth} ${pieceHeight * 0.65}`;
                path += ` L ${pieceWidth} ${pieceHeight}`;
            } else {
                path += ` L ${pieceWidth} ${pieceHeight * 0.35}`;
                path += ` Q ${pieceWidth - tabSize * 0.8} ${pieceHeight * 0.4} ${pieceWidth - tabSize * 0.8} ${pieceHeight * 0.5}`;
                path += ` Q ${pieceWidth - tabSize * 0.8} ${pieceHeight * 0.6} ${pieceWidth} ${pieceHeight * 0.65}`;
                path += ` L ${pieceWidth} ${pieceHeight}`;
            }

            // Bottom edge
            if (row === difficulty - 1) {
                path += ` L 0 ${pieceHeight}`;
            } else if (hasBottomTab) {
                path += ` L ${pieceWidth * 0.65} ${pieceHeight}`;
                path += ` L ${pieceWidth * 0.65} ${pieceHeight + tabSize}`;
                path += ` Q ${pieceWidth * 0.6} ${pieceHeight + tabSize * 1.3} ${pieceWidth * 0.5} ${pieceHeight + tabSize * 1.3}`;
                path += ` Q ${pieceWidth * 0.4} ${pieceHeight + tabSize * 1.3} ${pieceWidth * 0.35} ${pieceHeight + tabSize}`;
                path += ` L ${pieceWidth * 0.35} ${pieceHeight}`;
                path += ` L 0 ${pieceHeight}`;
            } else {
                path += ` L ${pieceWidth * 0.65} ${pieceHeight}`;
                path += ` Q ${pieceWidth * 0.6} ${pieceHeight - tabSize * 0.8} ${pieceWidth * 0.5} ${pieceHeight - tabSize * 0.8}`;
                path += ` Q ${pieceWidth * 0.4} ${pieceHeight - tabSize * 0.8} ${pieceWidth * 0.35} ${pieceHeight}`;
                path += ` L 0 ${pieceHeight}`;
            }

            // Left edge
            if (col === 0) {
                path += ` L 0 0`;
            } else if (hasLeftTab) {
                path += ` L 0 ${pieceHeight * 0.65}`;
                path += ` L ${-tabSize} ${pieceHeight * 0.65}`;
                path += ` Q ${-tabSize * 1.3} ${pieceHeight * 0.6} ${-tabSize * 1.3} ${pieceHeight * 0.5}`;
                path += ` Q ${-tabSize * 1.3} ${pieceHeight * 0.4} ${-tabSize} ${pieceHeight * 0.35}`;
                path += ` L 0 ${pieceHeight * 0.35}`;
                path += ` L 0 0`;
            } else {
                path += ` L 0 ${pieceHeight * 0.65}`;
                path += ` Q ${tabSize * 0.8} ${pieceHeight * 0.6} ${tabSize * 0.8} ${pieceHeight * 0.5}`;
                path += ` Q ${tabSize * 0.8} ${pieceHeight * 0.4} 0 ${pieceHeight * 0.35}`;
                path += ` L 0 0`;
            }

            path += ` Z`;

            return {
                path,
                hasTopTab,
                hasRightTab,
                hasBottomTab,
                hasLeftTab
            };
        }

        // Generate puzzle pieces
        function generatePuzzlePieces() {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = function() {
                    // Set canvas size
                    const maxSize = window.innerWidth < 768 ? Math.min(window.innerWidth - 40, 350) : 400;
                    const aspectRatio = img.width / img.height;
                    let canvasWidth, canvasHeight;

                    if (aspectRatio > 1) {
                        canvasWidth = maxSize;
                        canvasHeight = maxSize / aspectRatio;
                    } else {
                        canvasHeight = maxSize;
                        canvasWidth = maxSize * aspectRatio;
                    }

                    elements.canvas.width = canvasWidth;
                    elements.canvas.height = canvasHeight;
                    elements.ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                    elements.ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);

                    // Generate tab pattern
                    const newTabPattern = generateTabPattern(gameState.difficulty);
                    gameState.tabPattern = newTabPattern;

                    const pieceWidth = canvasWidth / gameState.difficulty;
                    const pieceHeight = canvasHeight / gameState.difficulty;
                    const pieces = [];

                    for (let row = 0; row < gameState.difficulty; row++) {
                        for (let col = 0; col < gameState.difficulty; col++) {
                            const x = col * pieceWidth;
                            const y = row * pieceHeight;

                            const shapeData = createPuzzleShape(
                                row, 
                                col, 
                                pieceWidth, 
                                pieceHeight, 
                                gameState.difficulty, 
                                newTabPattern
                            );

                            // Create piece canvas with extra space for tabs
                            const pieceCanvas = document.createElement('canvas');
                            const extraSpace = Math.min(pieceWidth, pieceHeight) * 0.4;
                            pieceCanvas.width = pieceWidth + extraSpace;
                            pieceCanvas.height = pieceHeight + extraSpace;
                            const pieceCtx = pieceCanvas.getContext('2d');

                            if (pieceCtx) {
                                pieceCtx.clearRect(0, 0, pieceCanvas.width, pieceCanvas.height);

                                // Create clipping path
                                const path2D = new Path2D(shapeData.path);
                                pieceCtx.save();
                                pieceCtx.translate(extraSpace / 2, extraSpace / 2);
                                pieceCtx.clip(path2D);

                                // Draw image piece
                                pieceCtx.drawImage(
                                    elements.canvas, 
                                    x, 
                                    y, 
                                    pieceWidth, 
                                    pieceHeight, 
                                    0, 
                                    0, 
                                    pieceWidth, 
                                    pieceHeight
                                );
                                pieceCtx.restore();

                                // Draw border
                                pieceCtx.translate(extraSpace / 2, extraSpace / 2);
                                pieceCtx.strokeStyle = "#8B5CF6";
                                pieceCtx.lineWidth = 2;
                                pieceCtx.stroke(path2D);

                                pieces.push({
                                    id: row * gameState.difficulty + col,
                                    row,
                                    col,
                                    correctX: x,
                                    correctY: y,
                                    width: pieceWidth,
                                    height: pieceHeight,
                                    isPlaced: false,
                                    imageData: pieceCanvas.toDataURL(),
                                    clipPath: shapeData.path,
                                    hasTopTab: shapeData.hasTopTab,
                                    hasRightTab: shapeData.hasRightTab,
                                    hasBottomTab: shapeData.hasBottomTab,
                                    hasLeftTab: shapeData.hasLeftTab
                                });
                            }
                        }
                    }

                    // Shuffle pieces
                    gameState.puzzlePieces = pieces.sort(() => Math.random() - 0.5);
                    resolve();
                };
                img.onerror = function() {
                    console.error("Failed to load image");
                                    resolve();
            };
            img.src = gameState.image;
        });
    }

    // Format time
    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    // Update stats display
    function updateStats() {
        elements.timeDisplay.textContent = formatTime(gameState.stats.timeElapsed);
        elements.movesDisplay.textContent = gameState.stats.moves;
        
        const placedPieces = gameState.puzzlePieces.filter(p => p.isPlaced).length;
        const totalPieces = gameState.puzzlePieces.length;
        const percentage = totalPieces > 0 ? Math.round((placedPieces / totalPieces) * 100) : 0;
        
        elements.progressPercent.textContent = `${percentage}%`;
        elements.progressFill.style.width = `${percentage}%`;
        
        // Update remaining pieces count
        const remaining = totalPieces - placedPieces;
        elements.remainingPieces.textContent = `${remaining} tersisa`;
        
        if (remaining === 0) {
            elements.noPieces.style.display = 'block';
        } else {
            elements.noPieces.style.display = 'none';
        }
    }

    // Start game
    async function startGame() {
        gameState.isPlaying = true;
        gameState.isPaused = false;
        gameState.stats = {
            moves: 0,
            timeElapsed: 0,
            isComplete: false
        };
        gameState.selectedPiece = null;
        
        // Show game area
        elements.previewCard.style.display = 'none';
        elements.puzzleSection.style.display = 'block';
        elements.gameActions.style.display = 'flex';
        
        // Generate puzzle pieces
        await generatePuzzlePieces();
        
        // Set puzzle container size
        elements.puzzleContainer.style.width = `${elements.canvas.width}px`;
        elements.puzzleContainer.style.height = `${elements.canvas.height}px`;
        
        // Update grid background
        elements.puzzleContainer.querySelector('.puzzle-grid').style.backgroundSize = 
            `${elements.canvas.width / gameState.difficulty}px ${elements.canvas.height / gameState.difficulty}px`;
        
        // Render pieces
        renderPieces();
        updateStats();
        
        // Start timer
        if (timer) clearInterval(timer);
        timer = setInterval(() => {
            if (!gameState.isPaused && !gameState.stats.isComplete) {
                gameState.stats.timeElapsed++;
                elements.timeDisplay.textContent = formatTime(gameState.stats.timeElapsed);
            }
        }, 1000);
    }

    // Render pieces
    function renderPieces() {
        // Clear pieces container
        elements.piecesContainer.innerHTML = '';
        
        // Render unplaced pieces
        gameState.puzzlePieces
            .filter(piece => !piece.isPlaced)
            .forEach(piece => {
                const pieceElement = document.createElement('div');
                pieceElement.className = `piece-thumbnail ${gameState.selectedPiece === piece.id ? 'selected' : ''}`;
                pieceElement.innerHTML = `
                    <img src="${piece.imageData}" alt="Piece ${piece.id + 1}" style="width: 100%;">
                    <div class="piece-number">${piece.id + 1}</div>
                    ${gameState.selectedPiece === piece.id ? '<div class="piece-overlay"></div>' : ''}
                `;
                pieceElement.addEventListener('click', () => selectPiece(piece.id));
                elements.piecesContainer.appendChild(pieceElement);
            });
        
        // Render placed pieces
        const placedPieces = gameState.puzzlePieces.filter(piece => piece.isPlaced);
        placedPieces.forEach(piece => {
            const pieceElement = document.createElement('div');
            pieceElement.className = 'puzzle-piece';
            pieceElement.style.left = `${piece.correctX}px`;
            pieceElement.style.top = `${piece.correctY}px`;
            pieceElement.style.width = `${piece.width}px`;
            pieceElement.style.height = `${piece.height}px`;
            pieceElement.innerHTML = `
                <img src="${piece.imageData}" alt="Piece ${piece.id + 1}" style="width: 100%; height: 100%;">
                <div class="piece-check">✓</div>
            `;
            elements.puzzleContainer.appendChild(pieceElement);
        });
    }

    // Select piece
    function selectPiece(pieceId) {
        if (gameState.isPaused) return;
        
        const piece = gameState.puzzlePieces.find(p => p.id === pieceId);
        if (piece && !piece.isPlaced) {
            gameState.selectedPiece = gameState.selectedPiece === pieceId ? null : pieceId;
            
            // Update UI
            if (gameState.selectedPiece !== null) {
                elements.selectedPieceBadge.style.display = 'inline-block';
                elements.selectedPieceBadge.textContent = `Piece ${pieceId + 1} dipilih`;
                elements.selectedPieceNumber.textContent = pieceId + 1;
                elements.selectedHint.style.display = 'block';
                elements.puzzleContainer.classList.add('active');
            } else {
                elements.selectedPieceBadge.style.display = 'none';
                elements.selectedHint.style.display = 'none';
                elements.puzzleContainer.classList.remove('active');
            }
            
            renderPieces();
            
            // Haptic feedback for mobile
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
        }
    }

    // Handle puzzle area click
    function handlePuzzleAreaClick(e) {
        if (!gameState.selectedPiece || gameState.isPaused) return;
        
        const rect = elements.puzzleContainer.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Find selected piece
        const pieceIndex = gameState.puzzlePieces.findIndex(p => p.id === gameState.selectedPiece);
        if (pieceIndex === -1) return;
        
        const piece = gameState.puzzlePieces[pieceIndex];
        
        // Check if position is correct (with tolerance)
        const toleranceX = piece.width * 0.5; // 50% tolerance
        const toleranceY = piece.height * 0.5; // 50% tolerance
        
        const isCorrectPosition = 
            Math.abs(x - piece.correctX) < toleranceX && 
            Math.abs(y - piece.correctY) < toleranceY;
        
        if (isCorrectPosition) {
            // Place the piece
            gameState.puzzlePieces[pieceIndex].isPlaced = true;
            gameState.stats.moves++;
            
            // Check if puzzle is complete
            const isComplete = gameState.puzzlePieces.every(p => p.isPlaced);
            if (isComplete) {
                gameState.stats.isComplete = true;
                clearInterval(timer);
                showCelebration();
            }
            
            // Haptic feedback for success
            if (navigator.vibrate) {
                navigator.vibrate([100, 50, 100]);
            }
        } else {
            // Haptic feedback for error
            if (navigator.vibrate) {
                navigator.vibrate(200);
            }
        }
        
        // Reset selection
        gameState.selectedPiece = null;
        elements.selectedPieceBadge.style.display = 'none';
        elements.selectedHint.style.display = 'none';
        elements.puzzleContainer.classList.remove('active');
        
        // Update UI
        renderPieces();
        updateStats();
    }

    // Toggle hint
    function toggleHint() {
        gameState.showHint = !gameState.showHint;
        elements.hintContainer.style.display = gameState.showHint ? 'block' : 'none';
        elements.hintBtn.innerHTML = gameState.showHint ? '<span>👁️</span> Sembunyikan' : '<span>👁️</span> Hint';
    }

    // Shuffle pieces
    function shufflePieces() {
        gameState.puzzlePieces = gameState.puzzlePieces
            .map(piece => ({
                ...piece,
                isPlaced: false
            }))
            .sort(() => Math.random() - 0.5);
        
        gameState.selectedPiece = null;
        gameState.stats.moves++;
        
        elements.selectedPieceBadge.style.display = 'none';
        elements.selectedHint.style.display = 'none';
        elements.puzzleContainer.classList.remove('active');
        
        renderPieces();
        updateStats();
    }

    // Show celebration
    function showCelebration() {
        elements.modalTime.textContent = formatTime(gameState.stats.timeElapsed);
        elements.modalMoves.textContent = gameState.stats.moves;
        elements.modalDifficulty.textContent = getDifficultyLabel(gameState.difficulty);
        elements.celebrationModal.classList.add('active');
        
        // Celebration haptic
        if (navigator.vibrate) {
            navigator.vibrate([200, 100, 200, 100, 200]);
        }
    }

    // Play again
    function playAgain() {
        closeModal();
        startGame();
    }

    // Close modal
    function closeModal() {
        elements.celebrationModal.classList.remove('active');
    }

    // Reset game
    function resetGame() {
        gameState.isPlaying = false;
        gameState.isPaused = false;
        gameState.stats = {
            moves: 0,
            timeElapsed: 0,
            isComplete: false
        };
        gameState.selectedPiece = null;
        gameState.showHint = false;
        
        clearInterval(timer);
        
        // Show preview and hide game area
        elements.previewCard.style.display = 'block';
        elements.puzzleSection.style.display = 'none';
        elements.gameActions.style.display = 'none';
        elements.hintContainer.style.display = 'none';
        elements.hintBtn.innerHTML = '<span>👁️</span> Hint';
        
        // Update stats
        updateStats();
    }

    // Get difficulty label
    function getDifficultyLabel(difficulty) {
        switch (difficulty) {
            case 2: return 'Mudah (2x2)';
            case 3: return 'Sedang (3x3)';
            case 4: return 'Sulit (4x4)';
            case 5: return 'Expert (5x5)';
            default: return 'Sedang (3x3)';
        }
    }

    // Initialize the game
    init();
</script>
</body>
</html>
